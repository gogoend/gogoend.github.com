<body style="padding: 0;margin: 0">
    <div data-role="target" style="width:20px;height: 20px;background-color: chocolate"></div>
    <!-- <div class="outter" style="
    position: absolute;
    left: 30%;
    top: 30%;
    background-image:url('./stick_bg.svg');
    border-radius:50%;
    width: 500px;
    height:500px;
    background-color: rgba(0,0,0,0.5);">
        <div class="inner" style="width: 200px;
    height: 200px;
    background-color: rgba(255,255,255,0.5);
    position: absolute;
    top: 150px;
    left: 150px;
    box-shadow: 2px 2px 10px rgba(0,0,0,0.5);
    border-radius: 50%"></div>
    </div> -->

    <script src="./util.js"></script>

    <script>
        "use strict";
        //stick配置
        var stickConfig = {
            zoneSize: '500px',//外部尺寸
            stickSize: '200px',//内部尺寸
            position: [null, null],//位置
            target: document.querySelector('[data-role=target]'),//控制目标：DOM或THREE.Object3D
            moveFactor: 0.1,//移动因数
        }

        //stick初始化
        var stickInit = function (conf) {
            //创建DOM
            var zone = document.createElement('div');
            zone.setAttribute('data-role', 'zone');
            zone.style.cssText = 'position: absolute;background-image:url(\'./stick_bg.svg\');border-radius:50%;background-color: rgba(0,0,0,0.5);';
            zone.style.width = conf.zoneSize;//'500px';
            zone.style.height = conf.zoneSize;//'500px';
            zone.style.top = '30%';
            zone.style.left = '30%';

            var stick = document.createElement('div');
            stick.setAttribute('data-role', 'stick');
            stick.style.cssText = 'background-color: rgba(255,255,255,0.5);position: absolute;box-shadow: 2px 2px 10px rgba(0,0,0,0.5);border-radius: 50%;';
            stick.style.width = conf.stickSize;//'200px';
            stick.style.height = conf.stickSize;//'200px';
            stick.style.top = '150px';
            stick.style.left = '150px';
            zone.appendChild(stick)
            document.body.appendChild(zone);

            //获得外部容器（定界框）
            var zone = document.querySelector('[data-role=zone]');
            //获得内部手柄（摇杆）
            var stick = document.querySelector('[data-role=stick]');
            //变换目标
            var target = conf.target;
            var originX = parseInt(stick.style.left);
            var originY = parseInt(stick.style.top);
            //用于计算当拖动超出范围时手柄的锁定坐标（来自nipplejs）
            var findLockedCoord = function (position, distance, radius) {
                var b = [];
                b.x = /*position.x - */distance * Math.cos(radius);
                b.y =/*position.y - */distance * Math.sin(radius);
                //console.log(position.x+' '+position.y+'  '+distance * Math.cos(radius)+' '+distance * Math.sin(radius));
                return b;
            };
            //

            //处理鼠标移动
            var mouseMoveHandler = function (e) {

                var result = {
                    stickLeft: undefined,
                    stickTop: undefined,                 //用于计算stick样式
                    stickOffsetLeft: undefined,
                    stickOffsetTop: undefined,           //获得stick相对于zone中心的x,y偏移量
                    distance: undefined,                 //获得stick相对于zone中心的距离
                    force: undefined,                     //当stick移动超出zone时，移出以后stick
                    rad: undefined,
                    deg: undefined,                      //获得stick相对于zone中心的旋转度数
                    lockedPos: undefined,                //当stick移动超出zone时，获得stick在边缘锁定的位置
                    transformMatrix: undefined                    //变换矩阵
                };

                result.stickLeft = e.clientX - 0.5 * parseInt(getStyle(stick).width) - parseInt(getStyle(zone).left);// inner.style.left
                result.stickTop = e.clientY - 0.5 * parseInt(getStyle(stick).height) - parseInt(getStyle(zone).top);// inner.style.top
                result.stickOffsetLeft = result.stickLeft - originX;
                result.stickOffsetTop = result.stickTop - originY;

                //手柄的偏移量、偏移角度
                result.distance = gougu(result.stickLeft - originX, result.stickTop - originY);
                result.force = result.distance;
                result.rad = Math.atan2(result.stickTop - originY, result.stickLeft - originX);
                result.deg = result.rad * (180 / Math.PI);
                var lockedDistanceOffset = (parseInt(getStyle(zone).height) / 2 - parseInt(getStyle(stick).height) / 2);

                //处理偏移量超过外容器边界的情况，超出时锁定内部手柄到定界框边沿
                if (result.distance > lockedDistanceOffset) {
                    console.log('outter');
                    //锁定偏移距离
                    //result.distance = (parseInt(getStyle(outter).height) / 2 - parseInt(getStyle(inner).height) / 2);
                    result.lockedPos = findLockedCoord({
                        x: parseInt(result.stickLeft),
                        y: parseInt(result.stickTop)
                    }, lockedDistanceOffset, result.rad);
                    result.force = result.distance;
                    result.distance = lockedDistanceOffset;
                    result.stickLeft = result.lockedPos.x + originX;
                    result.stickTop = result.lockedPos.y + originY;

                    //计算移出以后的偏移量，并同步角度变化
                    // result.continueX = e.clientX - 0.5 * parseInt(getStyle(stick).width) - parseInt(getStyle(zone).left);
                    // result.continueY = e.clientY - 0.5 * parseInt(getStyle(stick).height) - parseInt(getStyle(zone).top);
                    //result.continueDistanceOffset = gougu(result.stickLeft - originX , result.stickTop - originY);
                    //偏移距离被锁定，但鼠标移出后角度不应当锁定，emmmmmm
                    // result.rad;
                    // result.degOffset;
                }


                //矩阵相关部分
                var translateMatrix3 = originMatrix3.slice(0);
                var rotateMatrix3 = originMatrix3.slice(0);

                if (target instanceof Element === true) {
                    //原始矩阵
                    var rawMatrix3 = parseTransformMatrix(getStyle(target).transform);

                    //平移矩阵
                    translateMatrix3[6] = result.stickOffsetLeft * conf.moveFactor;
                    translateMatrix3[7] = result.stickOffsetTop * conf.moveFactor;

                    //旋转矩阵
                    rotateMatrix3[0] = Math.cos(result.rad);
                    rotateMatrix3[1] = -Math.sin(result.rad);
                    rotateMatrix3[3] = Math.sin(result.rad);
                    rotateMatrix3[4] = Math.cos(result.rad);

                    //矩阵相乘
                    //console.log(parseTransformMatrix(getStyle(target).transform));
                    // result.transformMatrix = martixMuitply(rawMatrix3,martixMuitply(rotateMatrix3,translateMatrix3));
                    result.transformMatrix = martixMuitply(rawMatrix3, translateMatrix3);

                    // result.transformMatrix = martixMuitply(translateMatrix3, rotateMatrix3);

                    console.log([rawMatrix3, translateMatrix3, rotateMatrix3, result.transformMatrix])

                    result.cssTransformText = 'matrix(' + result.transformMatrix[0] + ',' + result.transformMatrix[1] + ',' + result.transformMatrix[3] + ',' + result.transformMatrix[4] + ',' + result.transformMatrix[6] + ',' + result.transformMatrix[7] + ')';
                }
                // if (console.table) {
                //     console.table(result);
                // } else {
                //     console.log(result)
                // }

                //console.log(result)


                // if (inner.offsetTop > 300) {
                //     inner.style.top = 300
                // }
                // if (inner.offsetTop < 0) {
                //     inner.style.top = 0
                // }
                // if (inner.offsetLeft > 300) {
                //     inner.style.left = 300
                // }
                // if (inner.offsetLeft < 0) {
                //     inner.style.left = 0
                // }
                // console.log(inner.style.left + ' ' + inner.style.top)
                // console.log(inner.offsetLeft + ' ' + inner.offsetTop);
                // console.log(e.clientX + ' ' + e.clientY);
                // var disX, disY;
                // disX = e.clientX - inner.offsetLeft;
                // disY = e.clientY - inner.offsetTop;
                // inner.style.left = e.clientX - disX + 'px';
                // inner.style.top = e.clientY - disY + 'px';
                // console.log(disX+' '+disY);
                return result;

            }

            //处理鼠标事件
            function mouseHandler(e) {
                // if (e.target !== inner) {
                //     //console.log(e)
                //     return;
                // }

                switch (e.type) {
                    case 'mousedown': {
                        // console.log('mousedown');
                        document.body.addEventListener('mousemove', mouseHandler, false);
                        document.body.addEventListener('mouseup', mouseHandler, false);
                        break;
                    };
                    case 'mousemove': {
                        var result = mouseMoveHandler(e);
                        stick.style.left = result.stickLeft + 'px';
                        stick.style.top = result.stickTop + 'px';
                        target.style.transform = result.cssTransformText;
                        break;
                    };
                    case 'mouseup': {
                        // console.log('mouseup')
                        stick.style.left = originX + 'px';
                        stick.style.top = originY + 'px';
                        document.body.removeEventListener('mouseup', mouseHandler, false);
                        document.body.removeEventListener('mousemove', mouseHandler, false);
                        break;
                    }
                }
            }


            document.body.addEventListener('mousedown', mouseHandler, false);
            //inner.addEventListener('mousedown', mouseHandler, false);

            //阻止默认事件
            document.body.addEventListener('contextmenu', function (e) {
                e.preventDefault();
            }, false);
        }

        stickInit(stickConfig);
    </script>
</body>